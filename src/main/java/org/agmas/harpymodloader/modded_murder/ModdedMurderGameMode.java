package org.agmas.harpymodloader.modded_murder;

import dev.doctor4t.trainmurdermystery.api.Role;
import dev.doctor4t.trainmurdermystery.api.TMMRoles;
import dev.doctor4t.trainmurdermystery.cca.GameWorldComponent;
import dev.doctor4t.trainmurdermystery.cca.ScoreboardRoleSelectorComponent;
import dev.doctor4t.trainmurdermystery.cca.TrainWorldComponent;
import dev.doctor4t.trainmurdermystery.client.gui.RoleAnnouncementTexts;
import dev.doctor4t.trainmurdermystery.game.GameConstants;
import dev.doctor4t.trainmurdermystery.game.MurderGameMode;
import dev.doctor4t.trainmurdermystery.util.AnnounceWelcomePayload;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.fabricmc.loader.impl.util.log.Log;
import net.fabricmc.loader.impl.util.log.LogCategory;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.Identifier;
import net.minecraft.world.World;
import org.agmas.harpymodloader.Harpymodloader;
import org.agmas.harpymodloader.config.HarpyModLoaderConfig;
import org.agmas.harpymodloader.events.ModdedRoleAssigned;
import org.jetbrains.annotations.NotNull;

import java.util.*;

public class ModdedMurderGameMode extends MurderGameMode {

    public ModdedMurderGameMode(Identifier identifier) {
        super(identifier);
    }

    @Override
    public void initializeGame(ServerWorld serverWorld, GameWorldComponent gameWorldComponent, List<ServerPlayerEntity> players) {

        Harpymodloader.refreshRoles();

        ((TrainWorldComponent)TrainWorldComponent.KEY.get(serverWorld)).setTimeOfDay(TrainWorldComponent.TimeOfDay.NIGHT);
        gameWorldComponent.clearRoleMap();
        for(ServerPlayerEntity player : players) {
            gameWorldComponent.addRole(player, TMMRoles.CIVILIAN);
        }

        int roleCount = assignVannilaRoles(serverWorld,gameWorldComponent,players);

        assignCivilianReplacingRoles(roleCount,serverWorld,gameWorldComponent,players);

        assignKillerReplacingRoles(roleCount,serverWorld,gameWorldComponent,players);

        for(ServerPlayerEntity player : players) {
            if (Harpymodloader.VANNILA_ROLES.contains(gameWorldComponent.getRole(player))) {
                ServerPlayNetworking.send(player, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(gameWorldComponent.isRole(player, TMMRoles.KILLER) ? RoleAnnouncementTexts.KILLER : (gameWorldComponent.isRole(player, TMMRoles.VIGILANTE) ? RoleAnnouncementTexts.VIGILANTE : RoleAnnouncementTexts.CIVILIAN)), roleCount, players.size() - roleCount));
            } else {
                ServerPlayNetworking.send(player, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(Harpymodloader.autogeneratedAnnouncements.get(gameWorldComponent.getRole(player))), roleCount, players.size() - roleCount));
            }
        }

        Harpymodloader.FORCED_MODDED_ROLE.clear();
        Harpymodloader.FORCED_MODDED_ROLE_FLIP.clear();
    }

    public void assignCivilianReplacingRoles(int desiredRoleCount, ServerWorld serverWorld, GameWorldComponent gameWorldComponent, List<ServerPlayerEntity> players) {

        // shuffle roles so modded roles are different every time
        ArrayList<Role> shuffledCivillianRoles = new ArrayList<>(TMMRoles.ROLES);
        shuffledCivillianRoles.removeIf(role -> Harpymodloader.VANNILA_ROLES.contains(role) || role.canUseKiller() || !role.isInnocent());

        ArrayList<Role> shuffledNeutralRoles = new ArrayList<>(TMMRoles.ROLES);
        shuffledNeutralRoles.removeIf(role -> Harpymodloader.VANNILA_ROLES.contains(role) || role.canUseKiller() || role.isInnocent());

        // 获取所有平民玩家，而不仅仅是可被替换的角色
        ArrayList<ServerPlayerEntity> playersForCivillianRoles = new ArrayList<>(players);
        playersForCivillianRoles.removeIf(player -> {
            Role role = gameWorldComponent.getRole(player);
            return !Harpymodloader.OVERWRITE_ROLES.contains(role) || role.canUseKiller();
        });
        Collections.shuffle(shuffledCivillianRoles);
        Collections.shuffle(shuffledNeutralRoles);

        int neutralDesiredRoleCount = (int)Math.floor(((float)players.size() / 6F));
        int assignedNeutralRoles = 0;
        int neutralRoleCount = 0;

        for (Role role : shuffledNeutralRoles) {
            if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
            neutralRoleCount++;
        }

        // 先分配中立角色
        for (Role role : shuffledNeutralRoles) {
            if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
            if (assignedNeutralRoles >= neutralDesiredRoleCount) continue;
            int roleSpecificDesireCount = Math.min((int) Math.ceil((double) playersForCivillianRoles.size() / neutralRoleCount), desiredRoleCount);
            if (Harpymodloader.ROLE_MAX.containsKey(role.identifier())) roleSpecificDesireCount = Harpymodloader.ROLE_MAX.get(role.identifier());

            assignedNeutralRoles += findAndAssignPlayers(roleSpecificDesireCount, role, playersForCivillianRoles,gameWorldComponent,serverWorld);
            playersForCivillianRoles.removeIf(player -> !gameWorldComponent.isRole(player, TMMRoles.CIVILIAN));
        }

        // 然后为剩余的所有平民分配其他角色
        playersForCivillianRoles.removeIf(player -> !gameWorldComponent.isRole(player, TMMRoles.CIVILIAN));

        int roleCount= 0;
        for (Role role : shuffledCivillianRoles) {
            if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
            roleCount++;
        }

        // 修改这里，确保所有剩余的平民都会被分配到角色
        int remainingCivilians = playersForCivillianRoles.size();
        if (roleCount > 0) {
            // 平均分配角色，确保每个平民都能得到一个额外身份
            int rolesPerType = Math.max(1, remainingCivilians / roleCount);
            
            for (Role role : shuffledCivillianRoles) {
                if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
                
                // 确保至少有一个该类型的角色会被分配
                int roleSpecificDesireCount = Math.min(rolesPerType, remainingCivilians);
                if (Harpymodloader.ROLE_MAX.containsKey(role.identifier())) {
                    roleSpecificDesireCount = Math.min(Harpymodloader.ROLE_MAX.get(role.identifier()), roleSpecificDesireCount);
                }

                int assigned = findAndAssignPlayers(roleSpecificDesireCount, role, playersForCivillianRoles,gameWorldComponent,serverWorld);
                remainingCivilians -= assigned;
                
                // 更新玩家列表，移除已分配角色的玩家
                playersForCivillianRoles.removeIf(player -> !gameWorldComponent.isRole(player, TMMRoles.CIVILIAN));
                
                // 如果没有剩余玩家，则退出循环
                if (playersForCivillianRoles.isEmpty()) break;
            }
            
            // 如果还有剩余的平民没有分配到角色，则继续分配直到全部分配完毕
            if (!playersForCivillianRoles.isEmpty()) {
                for (Role role : shuffledCivillianRoles) {
                    if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
                    
                    int roleSpecificDesireCount = Math.min(remainingCivilians, playersForCivillianRoles.size());
                    if (Harpymodloader.ROLE_MAX.containsKey(role.identifier())) {
                        roleSpecificDesireCount = Math.min(Harpymodloader.ROLE_MAX.get(role.identifier()), roleSpecificDesireCount);
                    }
                    
                    findAndAssignPlayers(roleSpecificDesireCount, role, playersForCivillianRoles, gameWorldComponent, serverWorld);
                    playersForCivillianRoles.removeIf(player -> !gameWorldComponent.isRole(player, TMMRoles.CIVILIAN));
                    
                    if (playersForCivillianRoles.isEmpty()) break;
                }
            }
        }
    }




    public void assignKillerReplacingRoles(int desiredRoleCount, ServerWorld serverWorld, GameWorldComponent gameWorldComponent, List<ServerPlayerEntity> players) {

        // shuffle roles so modded roles are different every time
        ArrayList<Role> shuffledKillerRoles = new ArrayList<>(TMMRoles.ROLES);
        shuffledKillerRoles.removeIf(role -> Harpymodloader.VANNILA_ROLES.contains(role) || !role.canUseKiller());

        ArrayList<ServerPlayerEntity> playersForKillerRoles = new ArrayList<>(players);
        playersForKillerRoles.removeIf(player -> {
            Role role = gameWorldComponent.getRole(player);
            return !Harpymodloader.OVERWRITE_ROLES.contains(role) || !role.canUseKiller();
        });

        Collections.shuffle(shuffledKillerRoles);

        int roleCount= 0;
        for (Role role : shuffledKillerRoles) {
            if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
            roleCount++;
        }
        for (Role role : shuffledKillerRoles) {
            if (HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath())) continue;
            int roleSpecificDesireCount = Math.min((int) Math.max(Math.round((double) playersForKillerRoles.size() / roleCount),1), desiredRoleCount);
            if (Harpymodloader.ROLE_MAX.containsKey(role.identifier())) roleSpecificDesireCount = Harpymodloader.ROLE_MAX.get(role.identifier());

            findAndAssignPlayers(roleSpecificDesireCount, role, playersForKillerRoles,gameWorldComponent,serverWorld);
            playersForKillerRoles.removeIf(player -> {
                Role role2 = gameWorldComponent.getRole(player);
                return !Harpymodloader.OVERWRITE_ROLES.contains(role2);
            });
        }
    }

    private static int findAndAssignPlayers(int desiredRoleCount, Role role, @NotNull List<ServerPlayerEntity> players, GameWorldComponent gameWorldComponent, World world) {

        ArrayList<ServerPlayerEntity> assignedPlayers = new ArrayList<>();

        if (Harpymodloader.FORCED_MODDED_ROLE.containsKey(role)) {
            for (UUID uuid : Harpymodloader.FORCED_MODDED_ROLE.get(role)) {
                PlayerEntity player = world.getPlayerByUuid(uuid);
                if (player instanceof ServerPlayerEntity serverPlayer) {
                    if (players.contains(serverPlayer)) {
                        assignedPlayers.add(serverPlayer);
                        gameWorldComponent.addRole(player,role);
                        --desiredRoleCount;
                        ModdedWeights.roleRounds.get(role).put(player.getUuid(), ModdedWeights.roleRounds.get(role).getOrDefault(player.getUuid(), 1) + 1);
                    }
                }
            }
        }

        HashMap<ServerPlayerEntity, Float> map = new HashMap<>();
        float total = 0.0F;

        for(ServerPlayerEntity player : players) {
            if (!Harpymodloader.FORCED_MODDED_ROLE_FLIP.containsKey(player.getUuid()) && Harpymodloader.OVERWRITE_ROLES.contains(gameWorldComponent.getRole(player))) {
                float weight = (float)Math.exp((-ModdedWeights.roleRounds.get(role).getOrDefault(player.getUuid(),1) * 4));
                if (!gameWorldComponent.areWeightsEnabled()) {
                    weight = 1.0F;
                }

                map.put(player, weight);
                total += weight;
            }
        }

        for(int i = 0; i < desiredRoleCount; ++i) {
            float random = world.getRandom().nextFloat() * total;

            for(Map.Entry<ServerPlayerEntity, Float> entry : map.entrySet()) {
                if (!Harpymodloader.FORCED_MODDED_ROLE_FLIP.containsKey(entry.getKey().getUuid()) && Harpymodloader.OVERWRITE_ROLES.contains(gameWorldComponent.getRole(entry.getKey()))) {
                    random -= entry.getValue();
                    if (random <= 0.0F) {
                        assignedPlayers.add(entry.getKey());
                        total -= entry.getValue();
                        map.remove(entry.getKey());
                        ModdedWeights.roleRounds.get(role).put(entry.getKey().getUuid(), ModdedWeights.roleRounds.get(role).getOrDefault(entry.getKey().getUuid(), 1) + 1);
                        break;
                    }
                }
            }
        }

        int i = 0;
        for(ServerPlayerEntity player : assignedPlayers) {
            gameWorldComponent.addRole(player,role);
            Log.info(LogCategory.GENERAL, player.getNameForScoreboard() + " || " + role.identifier());
            ModdedRoleAssigned.EVENT.invoker().assignModdedRole(player,role);
            i++;
        }
        return i;
    }

    public int assignVannilaRoles(ServerWorld serverWorld, GameWorldComponent gameWorldComponent, List<ServerPlayerEntity> players) {
        ScoreboardRoleSelectorComponent roleSelector = ScoreboardRoleSelectorComponent.KEY.get(serverWorld.getScoreboard());

        int killerCount = GameConstants.RoleConfig.killerCount;
        // 确保杀手数量不超过玩家数量
        killerCount = Math.min(killerCount, players.size());

        List<ServerPlayerEntity> playersForVigilante = new ArrayList<>(players);
        playersForVigilante.removeIf(player -> Harpymodloader.FORCED_MODDED_ROLE.containsKey(player.getUuid()));

        List<ServerPlayerEntity> playersForKiller = getServerPlayerEntities(players, roleSelector);


        int total = roleSelector.assignKillers(serverWorld, gameWorldComponent, playersForVigilante, killerCount);
        roleSelector.assignVigilantes(serverWorld, gameWorldComponent, playersForKiller, killerCount);
        return total;
    }

    private static @NotNull List<ServerPlayerEntity> getServerPlayerEntities(List<ServerPlayerEntity> players, ScoreboardRoleSelectorComponent roleSelector) {
        List<ServerPlayerEntity> playersForKiller = new ArrayList<>(players);
        playersForKiller.removeIf(player -> {
            if (Harpymodloader.FORCED_MODDED_ROLE_FLIP.containsKey(player.getUuid())) {
                if (Harpymodloader.FORCED_MODDED_ROLE_FLIP.get(player.getUuid()).canUseKiller()) {
                    roleSelector.forcedKillers.add(player.getUuid());
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        });
        return playersForKiller;
    }
}

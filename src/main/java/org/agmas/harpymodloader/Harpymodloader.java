package org.agmas.harpymodloader;

import dev.doctor4t.trainmurdermystery.api.GameMode;
import dev.doctor4t.trainmurdermystery.api.Role;
import dev.doctor4t.trainmurdermystery.api.TMMGameModes;
import dev.doctor4t.trainmurdermystery.api.TMMRoles;
import dev.doctor4t.trainmurdermystery.client.gui.RoleAnnouncementTexts;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.command.v2.ArgumentTypeRegistry;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.minecraft.command.argument.serialize.ConstantArgumentSerializer;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.text.MutableText;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.logging.Logger;

import net.minecraft.util.Language;
import org.agmas.harpymodloader.commands.*;
import org.agmas.harpymodloader.commands.argument.ModifierArgumentType;
import org.agmas.harpymodloader.commands.argument.RoleArgumentType;
import org.agmas.harpymodloader.config.HarpyModLoaderConfig;
import org.agmas.harpymodloader.modded_murder.ModdedMurderGameMode;
import org.agmas.harpymodloader.modded_murder.ModdedWeights;
import org.agmas.harpymodloader.modifiers.HMLModifiers;
import org.agmas.harpymodloader.modifiers.Modifier;

public class Harpymodloader implements ModInitializer {

    public static boolean isCommandEnabled = true;
    /**
     * 职业对应关系映射
     * 支持同时分配两个关联职业（例如医生+毒师）
     * Key: 主职业, Value: 关联职业
     */
    public static HashMap<Role,Role> Occupations_Roles = new HashMap<>();

    public static HashMap<Identifier, Integer> ROLE_MAX = new HashMap<>();
    public static HashMap<Identifier, Integer> MODIFIER_MAX = new HashMap<>();

    public static HashMap<Role, List<UUID>> FORCED_MODDED_ROLE = new HashMap<>();
    public static HashMap<UUID, Role> FORCED_MODDED_ROLE_FLIP = new HashMap<>();

    public static HashMap<Modifier, List<UUID>> FORCED_MODDED_MODIFIER = new HashMap<>();

    public static ArrayList<Role> VANNILA_ROLES = new ArrayList<>();
    public static ArrayList<Role> SPECIAL_ROLES = new ArrayList<>();
    public static ArrayList<Role> OVERWRITE_ROLES = new ArrayList<>();
    /**
     * Use 'Identifier().getPath();'
     *  */ 
    public static ArrayList<String> HIDDEN_MODIFIERS = new ArrayList<>();
    public static String MOD_ID = "harpymodloader";

    public static GameMode MODDED_GAMEMODE;
    public static boolean wantsToStartVannila = false;

    public static HashMap<Role, RoleAnnouncementTexts.RoleAnnouncementText> autogeneratedAnnouncements = new HashMap<>();
    public static HashMap<RoleAnnouncementTexts.RoleAnnouncementText, Role> autogeneratedAnnouncements_flip = new HashMap<>();

    public static final Logger LOGGER = Logger.getLogger("HarpyModLoader");
    @Override
    public void onInitialize() {
        ServerLifecycleEvents.SERVER_STARTED.register((server) -> {
            var team = server.getScoreboard().getTeam("harpymodloader_game");
            if (team == null) {
                server.getScoreboard().addTeam("harpymodloader_game");
            }
        });
        HarpyModLoaderConfig.HANDLER.load();
        VANNILA_ROLES.add(TMMRoles.LOOSE_END);
        VANNILA_ROLES.add(TMMRoles.CIVILIAN);
        VANNILA_ROLES.add(TMMRoles.KILLER);
        VANNILA_ROLES.add(TMMRoles.VIGILANTE);
        VANNILA_ROLES.add(TMMRoles.DISCOVERY_CIVILIAN);

        SPECIAL_ROLES.add(TMMRoles.LOOSE_END);
        SPECIAL_ROLES.add(TMMRoles.DISCOVERY_CIVILIAN);
        SPECIAL_ROLES.add(TMMRoles.CIVILIAN); // civilian is considered special since it can't be assigned, just given
                                              // out to everyone

        OVERWRITE_ROLES.add(TMMRoles.CIVILIAN);
        OVERWRITE_ROLES.add(TMMRoles.KILLER);

        ModdedWeights.init();

        registerCommands();
        HMLModifiers.init();

        MODDED_GAMEMODE = TMMGameModes.registerGameMode(Identifier.of(MOD_ID, "modded"),
                new ModdedMurderGameMode(Identifier.of(MOD_ID, "modded")));

        ServerLifecycleEvents.SERVER_STARTED.register((minecraftServer -> {
            refreshRoles();
        }));
    }
    
    public static void refreshRoles() {
        for (Role role : TMMRoles.ROLES.values()) {
            if (SPECIAL_ROLES.contains(role))
                continue;
            if (!ModdedWeights.roleRounds.containsKey(role)) {
                ModdedWeights.roleRounds.put(role, new HashMap<>());
                RoleAnnouncementTexts.RoleAnnouncementText roleAnnouncementText = new RoleAnnouncementTexts.RoleAnnouncementText(
                        role.identifier(), role.color());
                autogeneratedAnnouncements.put(role, roleAnnouncementText);
                autogeneratedAnnouncements_flip.put(roleAnnouncementText, role);
                RoleAnnouncementTexts.registerRoleAnnouncementText(role.identifier(), roleAnnouncementText);
            }
        }
    }

    public static void addToForcedModifiers(Modifier modifier, PlayerEntity player) {
        if (!FORCED_MODDED_MODIFIER.containsKey(modifier))
            FORCED_MODDED_MODIFIER.put(modifier, new ArrayList<>());
        FORCED_MODDED_MODIFIER.get(modifier).add(player.getUuid());
    }

    public static void addToForcedRoles(Role role, PlayerEntity player) {
        if (!FORCED_MODDED_ROLE.containsKey(role))
            FORCED_MODDED_ROLE.put(role, new ArrayList<>());
        FORCED_MODDED_ROLE.get(role).add(player.getUuid());

        FORCED_MODDED_ROLE_FLIP.put(player.getUuid(), role);
    }

    public static void setRoleMaximum(Identifier role, Integer max) {
        ROLE_MAX.put(role, max);
    }

    public static void setRoleMaximum(Role role, Integer max) {
        setRoleMaximum(role.identifier(), max);
    }

    public void registerCommands() {
        ArgumentTypeRegistry.registerArgumentType(
                Identifier.of(MOD_ID, "role"),
                RoleArgumentType.class,
                new RoleArgumentType.Serializer());
        ArgumentTypeRegistry.registerArgumentType(
                Identifier.of(MOD_ID, "modifier"),
                ModifierArgumentType.class,
                ConstantArgumentSerializer.of(ModifierArgumentType::create));

        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            ForceRoleCommand.register(dispatcher);
            SetEnabledRoleCommand.register(dispatcher);
            ListRolesCommand.register(dispatcher);
            ForceModifierCommand.register(dispatcher);
            SetEnabledModifierCommand.register(dispatcher);
            SetCompanionRoleCommand.register(dispatcher);
            SetRoleCountCommand.register(dispatcher);
            SetRoleWeightCommand.register(dispatcher);
            ToggleCustomRoleWeightsCommand.register(dispatcher);
            ChangeRoleCommand.register(dispatcher);
            AssignModifierCommand.register(dispatcher);
            SetOccupationRoleCommand.register(dispatcher);
        });
    }

    public static MutableText getRoleName(Role role) {
        if (role.identifier().getNamespace().equalsIgnoreCase("trainmurdermystery")) {
            return Text.translatable("announcement.role." + role.identifier().getPath());
        }
        if (!Language.getInstance().hasTranslation("announcement.role." + role.identifier().toTranslationKey())
                && Language.getInstance().hasTranslation("announcement.role." + role.identifier().getPath())) {
            return Text.translatable("announcement.role." + role.identifier().getPath());
        }
        return Text.translatable("announcement.role." + role.identifier().toTranslationKey());
    }

    /**
     * 添加职业对应关系（即同时分配两个职业）
     * 例如：setOccupationRole(医生, 毒师) 表示分配医生时也会分配毒师
     * 
     * @param mainRole 主职业
     * @param companionRole 関联职业
     */
    public static void setOccupationRole(Role mainRole, Role companionRole) {
        Occupations_Roles.put(mainRole, companionRole);
        LOGGER.info("Added occupation relation: " + mainRole.getIdentifier() + " -> " + companionRole.getIdentifier());
    }

    /**
     * 移除职业对应关系
     * 
     * @param mainRole 要移除对应关系的职业
     */
    public static void removeOccupationRole(Role mainRole) {
        Occupations_Roles.remove(mainRole);
        LOGGER.info("Removed occupation relation for: " + mainRole.getIdentifier());
    }

    /**
     * 清空所有职业对应关系
     */
    public static void clearOccupationRoles() {
        Occupations_Roles.clear();
        LOGGER.info("Cleared all occupation relations");
    }

    /**
     * 获取职业的关联职业
     * 
     * @param role 主职业
     * @return 关联职业，如果没有则返回null
     */
    public static Role getOccupationRole(Role role) {
        return Occupations_Roles.get(role);
    }

    /**
     * 检查职业是否有关联职业
     */
    public static boolean hasOccupationRole(Role role) {
        return Occupations_Roles.containsKey(role);
    }
}